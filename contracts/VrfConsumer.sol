// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./interfaces/IVRFAdapter.sol";
import "./BaseContract.sol";
import "./libraries/Errors.sol";
import "./libraries/Constants.sol";

// Chainlink VRF interfaces
interface VRFCoordinatorV2Interface {
    function requestRandomWords(
        bytes32 keyHash,
        uint64 subId,
        uint16 minimumRequestConfirmations,
        uint32 callbackGasLimit,
        uint32 numWords
    ) external returns (uint256 requestId);
    
    function getSubscription(uint64 subId) external view returns (
        uint96 balance,
        uint64 reqCount,
        address owner,
        address[] memory consumers
    );
}

interface VRFConsumerBaseV2Interface {
    function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external;
}

/**
 * @title VrfConsumer
 * @notice Production VRF adapter using Chainlink VRF v2
 * @dev Integrates with Chainlink VRF for secure randomness generation
 */
contract VrfConsumer is IVRFAdapter, BaseContract, VRFConsumerBaseV2Interface {
    struct RandomnessRequest {
        bool exists;
        bool fulfilled;
        address requester;
        uint32 numWords;
        uint256[] randomness;
        uint256 chainlinkRequestId;
    }
    
    VRFCoordinatorV2Interface public immutable vrfCoordinator;
    
    mapping(bytes32 => RandomnessRequest) private requests;
    mapping(uint256 => bytes32) private chainlinkToCustomId;
    
    // VRF Configuration
    bytes32 public keyHash;
    uint64 public subscriptionId;
    uint32 public callbackGasLimit;
    uint16 public requestConfirmations;
    
    uint256 private nonce;
    
    /**
     * @notice Constructor initializes the VRF consumer
     * @param initialOwner The initial owner of the contract
     * @param _vrfCoordinator Address of the Chainlink VRF Coordinator
     * @param _keyHash The key hash for the VRF
     * @param _subscriptionId The subscription ID for funding
     */
    constructor(
        address initialOwner,
        address _vrfCoordinator,
        bytes32 _keyHash,
        uint64 _subscriptionId
    ) BaseContract(initialOwner) {
        if (_vrfCoordinator == address(0)) revert Errors.ZeroAddress();
        
        vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
        keyHash = _keyHash;
        subscriptionId = _subscriptionId;
        callbackGasLimit = Constants.VRF_CALLBACK_GAS_LIMIT;
        requestConfirmations = Constants.VRF_REQUEST_CONFIRMATIONS;
    }
    
    /**
     * @notice Request random words from Chainlink VRF
     * @param requester The address requesting randomness
     * @param numWords The number of random words to request
     * @return requestId The unique identifier for this randomness request
     */
    function requestRandomness(address requester, uint32 numWords) 
        external 
        override 
        whenNotPaused 
        returns (bytes32 requestId) 
    {
        if (requester == address(0)) revert Errors.ZeroAddress();
        if (numWords == 0 || numWords > Constants.VRF_NUM_WORDS) revert InvalidConfiguration();
        
        // Check subscription status
        if (!_isSubscriptionValid()) revert InsufficientFunds();
        
        // Generate custom request ID
        requestId = keccak256(abi.encodePacked(
            block.timestamp,
            block.number,
            msg.sender,
            requester,
            nonce++
        ));
        
        // Request randomness from Chainlink VRF
        uint256 chainlinkRequestId;
        try vrfCoordinator.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        ) returns (uint256 _requestId) {
            chainlinkRequestId = _requestId;
        } catch (bytes memory reason) {
            revert VRFRequestFailed(string(reason));
        }
        
        // Store request mapping
        requests[requestId] = RandomnessRequest({
            exists: true,
            fulfilled: false,
            requester: requester,
            numWords: numWords,
            randomness: new uint256[](0),
            chainlinkRequestId: chainlinkRequestId
        });
        
        chainlinkToCustomId[chainlinkRequestId] = requestId;
        
        emit RandomnessRequested(requestId, requester);
        
        return requestId;
    }
    
    /**
     * @notice Callback function used by VRF Coordinator
     * @param chainlinkRequestId The Chainlink request ID
     * @param randomWords The random words generated by Chainlink VRF
     */
    function rawFulfillRandomWords(uint256 chainlinkRequestId, uint256[] memory randomWords) 
        external 
        override 
    {
        if (msg.sender != address(vrfCoordinator)) {
            revert UnauthorizedFulfillment(msg.sender);
        }
        
        bytes32 requestId = chainlinkToCustomId[chainlinkRequestId];
        if (requestId == bytes32(0)) revert InvalidRequestId(bytes32(chainlinkRequestId));
        
        RandomnessRequest storage request = requests[requestId];
        if (!request.exists || request.fulfilled) {
            revert InvalidRequestId(requestId);
        }
        
        request.fulfilled = true;
        request.randomness = randomWords;
        
        // Clean up mapping
        delete chainlinkToCustomId[chainlinkRequestId];
        
        emit RandomnessFulfilled(requestId, randomWords[0]);
    }
    
    /**
     * @notice Check if a randomness request has been fulfilled
     * @param requestId The request identifier
     * @return fulfilled Whether the request has been fulfilled
     */
    function isRequestFulfilled(bytes32 requestId) external view override returns (bool fulfilled) {
        return requests[requestId].fulfilled;
    }
    
    /**
     * @notice Get the randomness for a fulfilled request
     * @param requestId The request identifier
     * @return randomness The random number(s) generated
     */
    function getRandomness(bytes32 requestId) external view override returns (uint256[] memory randomness) {
        RandomnessRequest storage request = requests[requestId];
        if (!request.exists) revert InvalidRequestId(requestId);
        if (!request.fulfilled) revert VRFRequestFailed("Request not fulfilled");
        
        return request.randomness;
    }
    
    /**
     * @notice Get the status of a randomness request
     * @param requestId The request identifier
     * @return exists Whether the request exists
     * @return fulfilled Whether the request has been fulfilled
     * @return requester The address that made the request
     */
    function getRequestStatus(bytes32 requestId) external view override returns (
        bool exists,
        bool fulfilled,
        address requester
    ) {
        RandomnessRequest storage request = requests[requestId];
        return (request.exists, request.fulfilled, request.requester);
    }
    
    /**
     * @notice Update VRF configuration (admin only)
     * @param _keyHash The key hash for the VRF
     * @param _subscriptionId The subscription ID for funding
     * @param _callbackGasLimit The gas limit for the callback
     */
    function updateVRFConfig(
        bytes32 _keyHash,
        uint64 _subscriptionId,
        uint32 _callbackGasLimit
    ) external override onlyAdmin {
        if (_callbackGasLimit < 50000 || _callbackGasLimit > 2500000) {
            revert InvalidConfiguration();
        }
        
        keyHash = _keyHash;
        subscriptionId = _subscriptionId;
        callbackGasLimit = _callbackGasLimit;
        
        emit VRFConfigUpdated(_keyHash, _subscriptionId, _callbackGasLimit);
    }
    
    /**
     * @notice Update request confirmations (admin only)
     * @param _requestConfirmations Number of confirmations to wait
     */
    function updateRequestConfirmations(uint16 _requestConfirmations) external onlyAdmin {
        if (_requestConfirmations < 3 || _requestConfirmations > 200) {
            revert InvalidConfiguration();
        }
        requestConfirmations = _requestConfirmations;
    }
    
    /**
     * @notice Get current VRF configuration
     * @return _keyHash The current key hash
     * @return _subscriptionId The current subscription ID
     * @return _callbackGasLimit The current callback gas limit
     */
    function getVRFConfig() external view override returns (
        bytes32 _keyHash,
        uint64 _subscriptionId,
        uint32 _callbackGasLimit
    ) {
        return (keyHash, subscriptionId, callbackGasLimit);
    }
    
    /**
     * @notice Cancel a pending request (not supported in Chainlink VRF)
     * @param requestId The request to cancel
     */
    function cancelRequest(bytes32 requestId) external override {
        // Chainlink VRF doesn't support request cancellation
        // We can only mark it as cancelled in our records
        RandomnessRequest storage request = requests[requestId];
        if (!request.exists) revert InvalidRequestId(requestId);
        if (request.fulfilled) revert VRFRequestFailed("Request already fulfilled");
        if (request.requester != msg.sender && !admins[msg.sender] && msg.sender != owner()) {
            revert Errors.Unauthorized(msg.sender);
        }
        
        // Clean up mappings
        delete chainlinkToCustomId[request.chainlinkRequestId];
        delete requests[requestId];
    }
    
    /**
     * @notice Check if the adapter is ready to fulfill requests
     * @return ready Whether the adapter is properly configured and funded
     */
    function isReady() external view override returns (bool ready) {
        return !paused() && _isSubscriptionValid();
    }
    
    /**
     * @notice Get subscription details
     * @return balance The LINK balance of the subscription
     * @return reqCount The number of requests made
     * @return owner The owner of the subscription
     * @return consumers The list of consumer contracts
     */
    function getSubscriptionDetails() external view returns (
        uint96 balance,
        uint64 reqCount,
        address owner,
        address[] memory consumers
    ) {
        return vrfCoordinator.getSubscription(subscriptionId);
    }
    
    /**
     * @notice Check if the subscription is valid and funded
     * @return valid Whether the subscription is valid
     */
    function _isSubscriptionValid() internal view returns (bool valid) {
        try vrfCoordinator.getSubscription(subscriptionId) returns (
            uint96 balance,
            uint64,
            address,
            address[] memory consumers
        ) {
            // Check if subscription has balance and this contract is a consumer
            if (balance == 0) return false;
            
            for (uint256 i = 0; i < consumers.length; i++) {
                if (consumers[i] == address(this)) {
                    return true;
                }
            }
            return false;
        } catch {
            return false;
        }
    }
    
    /**
     * @notice Get the Chainlink request ID for a custom request ID
     * @param requestId The custom request identifier
     * @return chainlinkRequestId The corresponding Chainlink request ID
     */
    function getChainlinkRequestId(bytes32 requestId) external view returns (uint256 chainlinkRequestId) {
        return requests[requestId].chainlinkRequestId;
    }
    
    /**
     * @notice Emergency function to recover stuck requests
     * @param chainlinkRequestId The Chainlink request ID to recover
     */
    function recoverStuckRequest(uint256 chainlinkRequestId) external onlyAdmin {
        bytes32 requestId = chainlinkToCustomId[chainlinkRequestId];
        if (requestId != bytes32(0)) {
            delete chainlinkToCustomId[chainlinkRequestId];
            delete requests[requestId];
        }
    }
}